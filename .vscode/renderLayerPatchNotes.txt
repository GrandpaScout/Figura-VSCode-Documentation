renderlayers class cannot be found

It all starts in the `render_layers.json` file in the same folder as your bbmodel and texture.
The “render_layers” key of the json file points to a json list (using []) of compounds.

Values that go into a render layer object {} are:
“name”, default value is “layerName”
“vertexFormat”. There are many allowed values, but the default which you’ll most likely want to use is “POSITION_COLOR_TEXTURE_OVERLAY_LIGHT_NORMAL”.
“drawMode”, pretty much should always be QUADS, as is the default. Not sure what happens if you change it, probably nothing good
“expectedBufferSize”, default value 256. There’s no need to increase this, as it resizes automatically.
“hasCrumbling”, don’t know what this does but it’s true by default.
“translucent”, not entirely sure what this one exactly does either but it’s true by default.
“parameters”, which points to another json compound:

**Within parameters {}**
“shader”, with a string containing the name of your shader’s .json file. Without the .json on the end, though.
“lightmap”, whether the lightmap should be considered in this render layer. false by default.
“overlay”, whether the overlay should be considered in this render layer. false by default.
“cull”, whether this layer should be culled when you’re not on screen. true by default.
“depthTest”, referring to which depth test to use. “LEQUAL_DEPTH_TEST” by default.
“writeMaskState”, “ALL_MASK” by default
“lineWidth”, how thick lines should be drawn. Doesn’t have an effect when using QUADS, so practically pointless, but included anyway. 1.0 by default.
“layering”, “NO_LAYERING” by default.
“target”, “MAIN_TARGET” by default.
“transparency”, “NO_TRANSPARENCY” by default.
“texturing”, “DEFAULT_TEXTURING” by default.
“textures”: a list [] of strings. These strings are interpreted as minecraft texture identifiers, so you can get any texture in the game and put it here as long as you know how to access it. The special value “MY_TEXTURE” uses the texture of your figura avatar, and “SKIP” skips changing the texture. The default for “textures” is just a list containing “MY_TEXTURE”. 

Most of these values above aren’t very important to the average player, so here’s the rundown for what things you’ll be most likely to want to change:
The “name” of the render layer, the “shader” in the parameters of the render layer, and “lightmap”, “cull”, and “overlay” in the parameters of the render layer. As for all of these, you can see the example avatar for… well, an example.

After that, it’s the same format as minecraft core shaders, for which there already exist guides online. The string in your render_layers file needs to point to a .json file of the shader, and the “vertex” and “fragment” fields in there need to point to your .vsh and .fsh files for the shader.
You’re free to rename *some* of the things in the shader.json file, but the most important thing to remember is NOT to rename Sampler0, Sampler1, etc. those names are hardcoded. It’s best to leave the file alone other than changing “vertex” and “fragment”, and adding new uniforms.
Uniforms can be added to the already-existing uniforms list in the shader .json file.

Lua API for render layers includes just 2 functions: `CustomModelPart.setRenderLayer(“renderLayerName”)`, and `renderer.setUniform(“renderLayerName”, “uniformName”, value). Value is generally either a number, table, or vector depending on the uniform type you specified in the shader .json file.

An example avatar is here which has a basic™ setup with render layers, allowing you to use the action wheel to cloak yourself with a cool visual effect and see an example of how these avatars are made.

IMPORTANT: When you make a change to a shader file, whether it’s the shader .json, .vsh, or .fsh, it does NOT currently refresh automatically in game like when you edit script.lua or model.bbmodel. You may need to re-click the avatar again in the figura menu to reload it manually, the changes don’t automatically update in game.

There is also a new trust setting for Custom Render Layers, so if you can't see someone else's, that is something to check for them. Also, due to the fact that Iris completely changes vanilla rendering, you will not be able to see someone else's custom render layers if you're running shaders on Iris. They'll just appear the same as they would without custom render layers.

# RenderLayer API
* renderlayers.registerShader(name, format, vertexSource, fragmentSource, numSamplers, customUniforms)
  → Registers a new custom shader with the given name
  → If format is nil, uses the default of "POSITION_COLOR_TEXTURE_OVERLAY_LIGHT_NORMAL"
  → Code for the shader is contained in strings, vertexSource and fragmentSource
_
* renderlayers.registerRenderLayer(name, params, startFunction, endFunction)
  → Registers a new render layer with the given name
  → params is a table where you can set certain keys
    → vertexFormat - needs to match with the format of any shader you want to use. Same default as in registerShader()
    → hasCrumbling - don't know what this does, but it's true by default
    → translucent - also don't know this one, but true by default
  → startFunction and endFunction are two lua functions, called when you start rendering and when you stop rendering this layer. Functions which interact with openGL can only be called inside these

* renderlayers.setUniform(shaderName, uniformName, value) - Sets the value of the specified uniform in the specified shader. If the shader does not exist yet, does nothing
* renderlayers.setPriority(renderLayerName, value) - Sets the priority of a render layer. Layers with lower priorities are rendered first. By default, all priorities are 0
* renderlayers.getPriority(renderLayerName) - Gets the priority of the chosen render layer, or nil if it doesn't exist
* renderlayers.isShaderReady(shaderName) - Returns true or false depending on if the shader exists yet

# GL Functions
* These can only be called inside one of the functions sent to a registered render layer!

* useShader(shaderName): Uses the designated shader
* setTexture(index, textureName): Sets the designated texture based on the name
  → Special values include "MY_TEXTURE", "MAIN_FRAMEBUFFER", and "LAST_FRAMEBUFFER"
  → MY_TEXTURE uses your figura avatar texture
  → MAIN_FRAMEBUFFER uses what is currently drawn on the screen
  → LAST_FRAMEBUFFER uses what was drawn on the screen last frame
  → Otherwise, the name is treated as an identifier, so you can get game textures like "textures/block/bee_nest_top.png", for example
* enableLightmap() and disableLightmap(): Enables/disables lightmap testing
* enableOverlay() and disableOverlay(): Enables/disables overlay
* enableCull() and disableCull(): Enables/disables culling
* enableDepthTest() and disableDepthTest(): Enables/disables depth testing
* enableBlend() and disableBlend(): Enables/disables blending
* enableColorLogicOp() and disableColorLogicOp(): Enables/disables color logic operations
* enableStencil() and disableStencil(): Enables/disables stencil testing
* depthFunc(func): Sets the GL depth function
* depthMask(boolean): Enables/disables the GL depth mask
* blendFunc(src, dst): Sets the GL blend function
* blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha): Sets the GL blend function
* defaultBlendFunc(): A minecraft→specific function, resets the GL blend function to default
* blendEquation(equation): Sets the GL blend equation
* logicOp(operation): Sets the GL color logic operation
* colorMask(boolean): Enables/disables the GL color mask
* stencilMask(number): Sets the GL stencil mask
* stencilFunc(func, ref, mask): Sets the GL stencil function
* stencilOp(sfail, dpfail, dppass): Sets the GL stencil operations
* enableScissors(x, y, width, height): Enables GL scissors with those values
* disableScissors(): Disables GL scissors
* lineWidth(): Sets the shader line width

# GL Constants
* The API has a good number of the GL constants; it should have everything you need for the GL functions above. It has GL_NEVER, GL_FUNC_ADD, GL_ONE_MINUS_SRC_ALPHA, among many others_
* If figura doesn't have the value you need, for whatever reason, find the decimal value at https://javagl.github.io/GLConstantsTranslator/GLConstantsTranslator.html and use that

### Renderlayer API ###
* added renderlayers.restoreDefaults(), which resets the rendering to default state
* can now access the emissive texture in setTexture() using the key "MY_TEXTURE_EMISSIVE"

## Render Task Table ##
* function table used for changing render tasks data, which contains:
* setText(text) - only for text tasks
* setItem(item) - only for item tasks
* setBlock(block) - only for block tasks
* setItemMode(mode) - only item tasks, modes described above
* setRenderLayer(custom render layer) - only when it is NOT a text task
* setEmissive(boolean)
* set/getPos()
* set/getRot()
* set/getScale()

# RenderTasks API
* text now supports new lines
* for text tasks, added setLineSpacing() - changes the space in between lines
* some functions are now only accessible in their corresponding tasks
→ setText() - text tasks
→ setBlock() - block tasks
→ setItemMode() and setItem() - item tasks
→ setRenderLayer() - block and item tasks
